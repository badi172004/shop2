{"version":3,"file":"resolve-uri.umd.js","sources":["../src/resolve-uri.ts"],"sourcesContent":["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nconst enum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first 3ìnaöe“&Üˆ
xMwglíKÖ•ïím2]<àäFîíewÉdh™˙î+Éû	–ßûö«ÊÈOT/’ÌG6,ÑK™›8Í¡»˜¯ÛÿÅÎ3Xâﬂ,⁄ÅWHÇYPÅ€JP·èVRû!u¥}K.ÜI8(5ïã◊®é9Ì\.PÉKûóÉ€˛[W	æU¥ÿ≥w«€iQN¯mjØÒïUI∫–ˆ.≤*4˝Ú?Í—ÄÅÏuºîÔæ–G˘¢∂ÅA±É∏4õ	åﬁiPg˜≤;g' kZÿÁMHüÜ1?ã≈≤Q¯-„RE‚X%π GLi≥<Z±≤HøÛ1ê.´@\'d´Í¢Í&'6)⁄={∫÷Üù®Ωáb¸ºb0ŸwS;/~é4oÈV≥^„–€	g”.Z[x$OOràvﬁ;o€,∫ÜäKöcHQe⁄SB˜X:›…ˇwÇπ{“ràKyZÿÒõƒB° $« ∆›zª™Æ„ßÿù]vøŒ|„Zo™≠”õ[UB Vº˝‹Èùπ€ë#∏“ÜÙ≤ôÈ	…_à∫‚ƒ¿	b_™n≠ò–a¯=HÊåË3Dbª4⁄76ÇŒ AÒB¥ê‰|ÁËsVÑ∑Bëﬂ;,∂¬EuÊ§QŒ¬O¡Q!È'2Y€—[5óHvˆÍ0œTïãA0EáKv¸wdLdv@≈®Ÿ‡≤BzEØH§Ë“Æ1U’ÉÒ¢E„≥kª/Ôj≠k*pTP[(?tœ[?≤ˇ∑“~7é®&H4‚._Ny8›¨µ˛0ÛR¨(ıT:§∆‡9XÑªÚœbFÜÅ¢=Çú˛µôœ[R4°ô),S–Ü)be#ﬁÈÛu’;D\Ò◊X"—Èo¥ëbê—¸p&¶_ÃWˇi¯R›àÛ≤ºç6õà’˜πs7Ø¯=°||US,Z7ÈóØ˝<SU©AÊ2µΩÔà°fyO3∆öƒH⁄ëÔ3ëxòâ}z»µ»ÂaeÃöb¡l%±/È;ÅÛ∞-ül√ëvVò"ü˜î‹„sJ˚ıµµ„„i.«bÒﬁê§0»Ã ó¬/Sh´⁄àxFTNw‰i#1ÆÌ2ﬁÌËt^Öî$C∆‘6c#÷B¶'$#;ïáN!˜‚
’ªßâï§‹DD)◊Ô@ªî0d°]‚ÅO÷’ºxé8¨áÜ©Ñ]ÅDö∏≥ÙzÄ‹R†©ïﬂ‰í#»"˙bà$ø^'b=î(§ÔèmMÜ>Ôªév¢»]§+faIsùI° Xà4aÆS9âyˆ8ÆÏÅj\]¨∆Óå+Pÿƒ5ìŒvK∂≤õ`HK:5úRáö )’µn zÂ»s;}	u$$OÊ«¯¢g»Â`˘;ÑA†∫Xï·”∑4ëÎAt¨|∆{[ö√o!S”±ú¡ó‡ßîR´˝å¸X%Q‹—¬e•1rZœ{Pg±˚4j%
ñ˚Cx‹0Ü˛‡ \Y0‰√ Q—8„©'ÿ≠,wÒg	5∞¢E\∏û57û'@IÉûº+˘#‡ÿ∑Z–'“Âå~/a8Cí èv"\û;ìW¡s˚∏ÛNÉŸf g≈@Q<‚ïO´∆}õ∆=Xl—}Ì¿i—{‡¥‘5—;UT≤ßË√˝.XQΩ≠[cw••Ìçˆ•†˛S¶∆1ﬁ6/M7»Cg‡Ÿ€&‹∞gZ‘ƒ˝·6È
j®Ò\ñ¸´é3{ÃE≤˛¿ãtr1¿7Ä¿\å˝¬5rÄwÉèj+œ˜Gs“†C¢œÕé$º
YI ®cª»≈ÌùñÕﬂø
{ñôâd0◊ÖNÔY%È≠cNeôtb¡$mP6HzÁüã&[öÎH"K·“ZÉd:0˜…T™•¨gòŸ@|$ÑTw=RxﬂÁ6Å®ß5fRE@(ŒoŒ`ìl`œIaÙ§´%GI%ó¥SÂ@	‰«Õ
ø?¨ûÛæ“—NC›öòÏ¢µæﬁ¡;πTM”B˙@ËÉx1¶–ëRtì$˘¶y˜ 8¥äj±É(™*AΩµF˙¶≤ùäÂb“=¥z≈>r<.õ∏@≠VÚ!Õ`Eê•ÃcMÈMY»‹V¢E¸íNyÕ‘gŸîéñ"HáQHC0U`Ïo∆©Ò¿3—’à]ù≥»uŸ⁄$†ô=¥f&ŒVê9–êÇ•∆ìÙÿñg≤âæí6"U»à‡ç“Yà·ä©„HÏe™î-“Ÿ ¿§5“Ç¡88˚IûÕ«u=X»L≠uQ÷ÉÅƒkARË“—&˜jNeóKπ⁄Îû|Ω(t7bU-çy˘√Ω„Õ!ß©[L0F<
{O≥ëQ˘©4v\,}•⁄ÙÒus\f çŒg¿<…õãøø•Q>uZ3ß˜õÿ] •z∞í£ír‘ü«≠O…ãÒ™µíï∆+^&]6{l‰”
0ÿıª`Ö-FŸ–"†Í–œ;]t´ √óı∏fOÖ∏¡x‡6µ’ﬁZW2ˆ±b—/¢ÍT›	ˇ.ÿÂüW¬zÁÿ‹ÔªT#ªÖª€Dˇ·+ãc´ï%h#ŒDUóƒQÔ”ZRÍ'ˆlï÷$µï¡P`9j<ÂHÿ6ó5$,ÜV›Pj¢¨•YË{á·˘OzFÆ˘‰\µ8	0oR·ﬂ‘JËàB⁄•˙çsVKLoΩñ¨÷°_ÎKl§‚;súÌ}…Ïi≤É˛# ’\l—Tˆ◊Ñ¡Jˆò„iA«]›  «ı¡¸«i(∞Ìﬁíz[aIt˙m¨O»éMø#≈ÖÓåÏØnä8ì
ÚeÅÇi°„¶¢õ(§Õ≠< Œ3√ª\‚Ïâì«üÖ§Zøt1}µa Z%Qv¢¥MHr⁄nìGg∞Pœø_ˆ˛±DÀˆ≥MyÉ-5Ça¯÷H°¬ H’OGäI·Æk_îÎﬁÎD5V‚oΩPÔI~•á€•∑Çu√‹6˘UX{`ÃÑVKnô¸ü@ˇ2Œÿâò2ß∏©Z€~£
Õ7L!´–^ëƒ
‹¨'C*O˝´’Â˛cdUù≠7åJÑœ$QâëtÔo®àÇúÅ4qÒCPr¢‰µh⁄IMU£_	Ç◊¢TÌ"≠íõ ƒ6÷r2OüG„W0I¿—È.liﬁ9.[wùÒÕâV≈F"6˘1QPôÚi;œ6&´Q’zãì™]üWÿÈÍw5(Êÿƒ1Ø>k±,J™6<Ä˙—nö7¢∏*úàç„iußÖe“„·ˇ?6…*ì‘†¶wΩ•≈c@^Á’y√[˚(Q§>◊1B˘£'Æg°ˆJ-ÅTÊäDIÜ®â’0=—‚Î„ˆz?åó∏bÆLlR†h‡TíRBÉDëJ\gù&qÕ:)QØŸ÷ˇ°Î°{`™11vÖQìmVê◊ba&Ìh⁄Ñ>eüV=(B[±∏+ky~=${5¶ﬁPƒÊËõmcV]‡2¢-Ü…!¥|ñ–oΩaR—a|0ò^ÁT´Br¢∆•⁄3Æ˜-^º_HÉxõ÷l?ôÉOåH…I}qê®oÃ8%7÷Â¯~)újE˜ù±@0RZÎY¶b˚áT|¨çU∫ù¨˝	>˜˙-TÆı“ûµéGÈ{∞a‚z¶s˙]~õ¨–·ç5Ay˛Ä {†‹tc/¨WEG)ÃkÃÄp“Â‚˚¬ÛÆHKäì5UmeD∞ØÅÿ…˚iÍØÎÈ±x%Lÿ°éœ	Î__O!Êç>©YÚõÔŒ˚!›s>+Á’úQrt˚Z[†"^à_w¥© ®#}≤˛Ü±dÚª@›◊r„¬¥Y3Ú?∏> ∆¸*Z"uU·˛}oh¬œkÉò”+EG8?À§Y“Ÿk¸*ÄdP1ÒJ˛å¿0PM£ÍM?	Aòå¸Ã∞Y=≥†i«nsï»À<àüƒë=ÍŒ¢Ìr‰ÊwºaSæëUaKÃD¿ÉÙN~Ö	Yàâ¿iUëxª|s,PÑåoZRÃí„u
C'ıïE¥{x}¶ÒgïC™
i›∏∆;’ÊéjìùÙ+U7’RÖ3z…∆”Û>r˘ÉÛõ…Uûπ«Xâ|ã˜Ñ=*^@ÆÓJëm¥ KÕLÿ±éËíd.¶ë9YÍı˜'fC^[gbnE«fÎÁ%…˜(Ô=»CÁ!&ÇÖ◊Ò?â©CÆ›Ã´O6O¬Eæ.êÔ!Ê”k	»ø$ü_Ü¶qTá`‹i“éüd%YEÔ¢f‹≥ô“CelN% û Jv,å√	‚(˝j<N‚FrrñR≈£πﬁEx™4=øÓ£!F§f¿›^≥¥]âÀmF)Hzq◊Rnï,«liä-àèÚ	√∂Ë€ï¶yÑs£/ÓÛ“–
°¥GCî2o1_{JﬂÇ˚“,«ô¸–HÚF˙ì `Ú¢¬D Æ‰e4â6√%fMç!√µ/|∑5§K√Í4Òü∂Iê—GqÉ˙±‹≠?Ô7W‚ÍFﬁÑ{‰Á‘‡X_^ïoÊı s‘]ÇQÚF0kf∆û_ÀÍâ≈9íg_9 )ÜıëAP¸¨
ÅZ‹oP≤U3b–πﬁ Ì|C
DÉõ…©±hl*πÜ¡1Y§5hŒ¸á/∑t f£Y¡7[8ÁVíXq˘∞7"{˙ë^é&í™jÛX¿—˙Y#‰ÀÎL4S¥hrÏ÷⁄˛πÍ—≈ÊTDejÚ$ô›⁄o9Mö®îV˝œã€w™fW˛Nq∑"◊d0k¯—ÓŸÀàã]ßp?S6mó˝[3U>$»V+Ny¨L* )%Y*MUÖòv»â¬UöCÏ©ºbç–˝Ø"∂](;hÔüNbÈ‹. %Ì52ƒz¿¯ñg˛RoöJÓæ  sˇ∑´ß”•±Ì•f“É∫àÓ_!4Õƒﬂyƒ™ƒ≥°*6&çúN:Õvµµn’˜p´µ<F$©ƒ¡ûNVÊ
îVv◊ë8uˆ∞∞–»O∏∫Xàm;sxèîK˝R•k¨Œÿãp˚&Ì‡Ì-pJ‹ ◊ßà£tjŸ)=zÚd%É∞ª	‹4®ö>°êW≠˜‰Ì≤Íºf BrŸ*ëk ‚QCê∂ÎÄ(»“0Å—ÒG©‡∆sÿQY/ [–ÒŸW˘rd¶íæÿÎûÏÒ‚òa/à“WœñBvÈ>Ö¸É)◊ùÌã≤à_(VÎ>÷ÇoÒ^<>∆ı¸⁄¸,Úi°"‘Îm®˘.ﬂ|¢nÙxË™5k·°Ò‰©ôÓ|{(>‡Õ1Œkx—h¿inU˜KyòYhÃ,`.ùd⁄ŸmMe˜€˜0:ÒT€Cïæ¸÷£ËUÚ^PÄ,‚ì<úÅ[√v©ï•≥√µÃÙ5(öæ˙¬ä.m
wy4	^*iÎ}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"}