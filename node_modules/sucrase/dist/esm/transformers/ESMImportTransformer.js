


import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import elideImportEquals from "../util/elideImportEquals";
import getDeclarationInfo, {

  EMPTY_DECLARATION_INFO,
} from "../util/getDeclarationInfo";
import getImportExportSpecifierInfo from "../util/getImportExportSpecifierInfo";
import {getNonTypeIdentifiers} from "../util/getNonTypeIdentifiers";
import isExportFrom from "../util/isExportFrom";
import {removeMaybeImportAttributes} from "../util/removeMaybeImportAttributes";
import shouldElideDefaultExport from "../util/shouldElideDefaultExport";

import Transformer from "./Transformer";

/**
 * Class for editing import statements when we are keeping the code as ESM. We still need to remove
 * type-only imports in TypeScript and Flow.
 */
export default class ESMImportTransformer extends Transformer {
  
  
  

  constructor(
     tokens,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     keepUnusedImports,
    options,
  ) {
    super();this.tokens = tokens;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.keepUnusedImports = keepUnusedImports;;
    this.nonTypeIdentifiers =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getNonTypeIdentifiers(tokens, options)
        : new Set();
    this.declarationInfo =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getDeclarationInfo(tokens)
        : EMPTY_DECLARATION_INFO;
    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {
      return this.processImportEquals();
    }
    if (
      this.tokens.matches4(tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.
      for (let i = 0; i < 7; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches2(tt._export, tt.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (
      this.tokens.matches5(tt._export, tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)
    ) {
      // export import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.
      for (let i = 0; i < 8; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches1(tt._import)) {
      return this.processImport();
    }
    if (this.tokens.matches2(tt._export, tt._default)) {
      return this.processExportDefault();
    }
    if (this.tokens.matches2(tt._export, tt.braceL)) {
      return this.processNamedExports();
    }
    if (
      this.tokens.matches2(tt._export, tt.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(tt.braceL)) {
        while (!this.tokens.matches1(tt.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        // *
        this.tokens.removeToken();
        if (this.tokens.matches1(tt._as)) {
          // as
          this.tokens.removeToken();
          // ns
          this.tokens.removeToken();
        }
      }
      // Remove type re-export `... } from './T'`
      if (
        this.tokens.matchesContextual(ContextualKeyword._from) &&
        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)
      ) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      elideImportEquals(this.tokens);
    } else if (this.injectCreateRequireForImportRequire) {
      // We're using require in an environment (Node ESM) that doesn't provide
      // it as a global, so generate a helper to import it.
      // import -> const
      this.tokens.replaceToken("const");
      // Foo
      this.tokens.copyToken();
      // =
      this.tokens.copyToken();
      // require
      this.tokens.replaceToken(this.helperManager.getHelperName("require"));
    } else {
      // Otherwise, just switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

   processImport() {
    if (this.tokens.matches2(tt._import, tt.parenL)) {
      // Dynamic imports don't need to be transformed.
      return false;
    }

    const snapshot = this.tokens.snapshot();
    const allImportsRemoved = this.removeImportTypeBindings();
    if (allImportsRemoved) {
      this.tokens.restoreToSnapshot(snapshot);
      while (!this.tokens.matches1(tt.string)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
      if (this.tokens.matches1(tt.semi)) {
        this.tokens.removeToken();
      }
    }
    return true;
  }

  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
   removeImportTypeBindings() {
    this.tokens.copyExpectedToken(tt._import);
    if (
      this.tokens.matchesContextual(ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      return true;
    }

    if (this.tokens.matches1(tt.string)) {
      // This is a bare import, so we should proceed with the import.
      this.tokens.copyToken();
      return false;
    }

    // Skip the "module" token in import reflection.
    if (
      this.tokens.matchesContextual(ContextualKeyword._module) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)
    ) {
      this.tokens.copyToken();
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    let needsComma = false;

    // Handle default import.
    if (this.tokens.matches1(tt.name)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {
        this.tokens.removeToken();
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeImport = true;
        this.tokens.copyToken();
        if (this.tokens.matches1(tt.comma)) {
          // We're in a statement like:
          // import A, * as B from './A';
          // or
          // import A, {foo} from './A';
          // where the `A` is being kept. The comma should be removed if an only
          // if the next part of the import statement is elided, but that's hard
          // to determine at this point in the code. Instead, always remove it
          // and set a flag to abO<¯´‰ÀL÷Á	≠≠s+Ï‡?yà®ÙjSX|(ä√ËN;™Öß√…ü(E™n<‰ñı|Q:Œ.≠csùÀsÅü[ìKV†öP6?Uo|4¶–∑“GEàÒ¯d≤πà«8ü∑)Ø7M˚j√œüzÙ}sÑ+∆Ù›ŒVi ì\YNÔÔy‚`“ÏÔLÜ¬4ÄÎ◊Ú≠ ˚QOúk=	\—9§p∞ÛM8"^ÖK&ÙI⁄OgZ`°*<'ºˇ‰À˝'5„»tZ •f¡o‚\ÿ°›öªgŸ˝;Ø≠x˚≠Ï£¸’è
KyRÌ óT®˘«2\v⁄ä3¢2r–>≈(¬õíU`¨YGl!ÿ#÷Üí˙˜q2‚GØÇøŸgÆZÒÑ·7qæ/HdÇÅ1Z>íB-˛óòq\i"6pa+~ºh◊•4"˚∂e©U√ôµïD«¥8D‹
èÓLpÏ&¸…,‰“æƒcÍ™wÕr◊}í<y—aóÃãMlâ1É7ì±kr©q5ÃùÓÆÅ·wÀ#º&¥—÷|‚¯À,µá†0ıÒÖÙùﬁ¢o™-Õïî5:œ.&5ç”ª»≤ò™ñ†à˙$ö∏àíVÊòm“™Ij∞¢Ÿ¸†™/ﬁªπFØy=CdéÑ
:·…Â ;9MÎçuaÒ-¯£™¿ Cv(çrÊèà<˘∫h ¢≤m^;1Œ41@¸¡pî5p%ÁØ#a Ï-xBå;¶,D0
ç|= 
6µ;C◊ì‡\_æÄjm}∆J\Æà¨_ÿ∑ßI0r»˛˜tµeuF¿å!∞ŸûÏÅWÁ!Ω$lâ/0≈ŸR!Z
ÎÒ0HπÛd„πÜÚ≤ŸæS∏ŸcÆ£K€‚3·¿BÊá‘Å˙k5`yœÿ“Êı#ˇïWBç	6§õ<?[Õs7RSçNª2›”øÏŸ√»≈«ë≥KõK•
s∆	gIñd§kö∆ÉõuÜ)˙IñìÖÚÍ,TÊ1ˆ∂#¨˝∞=f÷›{yp†≈KIÈÙJR≠ãCÛCπˇ„8ãÜ¸5˜óH”•›::œngV1ß§êFW˙∑:…p,)]nµÕ@9>ËÊIª‹GåäøÅeëi$§æ7_∑VX,Æ…ßñ˝L?æ∞Y™£fc–Í^¯Xé„wÓe@Yftí¡Ò0[Oc>€˝R&√™w»“RÅ˚)RÏ)˜Îéùπª¬î:dÈ (Ç&∂,ÿ‘EA re{M®ƒAIù˘[∞ya	0Ä¬W°í5ØÚŸöN¶~+vbÚÚ∂8Œ Óß˛ ”¡u˘œA %I∞k¸®øìÉõí;=^èøèãASâΩ¯g?‚Nòh"≥úëN¬§DˇS¬µŸû%K±ò¿]É∆)∞å3K≤ö,ˇ£&¢'Ø©/Ê˝)kç(zûCªapû£jÜÖ◊jŒ@ÂD&Oûæã'¸ÕÇbÚÅ2xm¯’Cn¶Ì∆ﬂﬁÑ#0«ä.f©÷¡€J∆Ÿ
Ía—¿ñ!¡∏¯⁄p8©U4ƒuCâÔ7oUB÷Ã®í*–“ñ∫"(ÏßoÔòò≈ÍXg¥Páç‰≠ÿŒq;µ4¯º(©]rÙ7h? #e$G~q•1è◊xŒ‘9… éº¶\CüC›ø|6,¢Ã‡?˚,¶à˚py}ﬁlùSÜ‹/AiSG_DÌ»FN{˜Mè÷£˝CîgÓ†◊]PŸËH©C.®7T7¨ºû v›ÍõΩ¸·o¢πIÔ0ø.rˆ-‘E¶Ü¢j Ê5Ôdj¥§¿	2(5 *˜Œ;úâ—ö9ôn”,&/ûf˚j©Lﬂˇî€nYõ"‘Á-≠I^¬Ô´«jΩÏ,|
_0áõë”æY+Æ°V{?Í¶ä£ª`U≥±êøÒ»Hàÿ¸9ù1ãåFªåâ˙>êDªæ8I–“TYñ†{õÄ:√¶Yi`´â;(ÉròqÉÑî*îßw©ûÍ¬°;CUWÆ:œ/≥í45w’≈IW∏`∆ÓsqÆd-áÀá√’êyqjR‰`‚PKøÆ;j¸mVô∏˘· ¢⁄â˜®°ü>’¢h–Æ˛cq{ 
LÚ|Èë¯·ˆ®˘»	8QÍ‰g~{ˆ¢öÃøw,ÿÁ]∑)ÖÚKhÖŸé*à!(9Va\ø<˛ïŸ∂nü8‹ì>µm©kÜﬂJÎeÂÔT_´≠«∆P—∞Tﬂõ4ÏöVItLjãC¨E&RSp¶XùEÿÛW≈#{[≥∂“˜_ÊbbÌÏ.≠ÅU%Åzì,n?3k§N›eûø≠∂	™≈˘^d?8Ø´n8’5t÷#ıƒ£	-¥§ﬂhqì…ä|päﬂû®à>ëSßõ_î«îî)∑»KW„úï5"Ñ
^≠Á
$SX§tÏ E„còÎB∂¡í4¸Gx{(Wâó¸”∫b®jßı»Ï±`-àº:∑Í’Æ∫óΩÓò}nÆ§-Ua0mD∑#◊‚‘·$$[ˇæ1sÜ¡K»≠„—B¶¡í$™∞°{9¿Õk∑°†Ñâ§]§eZıgèÅ∞ôƒh‚çäQB_œ•≥hÈ6˜¨qå 9ÆñølRt$≥?√!§b®6´©´Ã2À?ÈjÅïh¸ä§õŸ?;Ü∫√o¡%«0îsóE!ËöÁ;¿∆D`J]äµ}ù¨nÁµ⁄iØÅyôòã ñæs{ß_î¢{Ÿ‰x‡„/U◊…vL«+≈¶ÉÅ|…Ò$ıäMqj#,WF+éÀî{xvZ”’‹¶XëÑtnUÎıÌ2ŸR:!îA¶]*èLKπ˘6;ß)[JøPÙô®+U≥3äÇ.–õdu—€_ƒ‰ôÑgr:œÍü=iº¿6KûÀƒ–ãG<XL5ı2j;∏aúi2ò0Q#—gÇrh±ÆÌ,ïL>ÍæÔMëÊ.â•—#)Ÿ¬1)
6:_‰FËŒ2–Ié!≥9Ï'Æ©’é‚µ.ı#.è“€…Êù±≥’øŒ¡"2•c∞˚ kßÈ˜$M`Ñ‡(AÒÀmF≥Ñ¥ﬁßà+«ÛEC–¨®≥C=O—¸™(¿Øﬂ|	ƒƒ√s⁄l1Ez1ˆçaO\û∆b-˛íîv◊ñó‚∏ó⁄8g ~Dªi+…Î>ŒW[ëq¨õÉ≈wÅEùaÿ]ŒR¶`$ï@˙—‚B'~˘HmãlﬂÙ*õßóÜàÃ®J2ÅgM”L_|Dﬂra>Æ ’∆áßr
ÕrÉÈoïÔ[6®Ó°E∆
0Íﬁñı“Ä<vÙé—OÕíM®`©˝ﬁ›∆WH[ßäç´{&N{‰Æ≤⁄‰R˙ `⁄–Luˆ/Ì>å'"‰t9Äq·™œãB2RÍ´Ω ›i`ÉÛüó]‚±ZÈÀv±4ŸæqfÙ]˙≥|Ä}ØVàˆ7ìí˝Ï≥µK1ªê‡sMÖ%øVî∂{G;^	À˙ûs&Œˆ?6‚µô‡'≠AxCX¨DLÖY&ô°ä≤Uº≥ü…>"ÚWn∆èÍÓåP}`¸ Iì«É‹±M¸)ôJparDâ"Ò£#Æâ˝Eo%ESSÇHpıæ-ñâ9∞∞ê>Fâ≠a‰J©à∂ÑΩﬂ≥“ÖÄÜıìU‚¬\e¥M„\u
∏TA:—ëÒVÉ∞ ë˚´Êw»DnÌyÁ∆
◊¯º-Rø $”Ô™x=ÿ ÀAtN∫O≤EÓñ1∫ZfÑ—ºÊG˙n°ZüD0ÈÃ∂◊Çá¶K¸ÙLw◊<Ç∑^•ﬁ≈6hp‹£O{‚k÷‡©F=/F·0ä3ßNiúwiOg‚ïæõ˙¥O;ˆ9*(4<ÀÃöf–ıEG¶#Ï^Â≈∏’Íù›dÄékjyäÓbå“±ÒÇãî?ë—Ÿ8@%¡B¶È;_ΩwÆû¨∆Fmkwå∑I∆ñˆö-œ∞«b(%yªs›l~$Ù∞∆(ıÄLÍì:oK“µ'ÓNUN&Údê—Ü_Û⁄ê`ØÜ»Î˜ä§◊b w4ÖD©6˘Ìè@_¶ÜÌ-Å≥s|˜‘Zhä:ûFÿÆ+CJB4™V
W`«‘OU¡±é-Lg¿D£ö≠&·j8¥|p9Ì(¯Hø©∫√ø°xÑzÂCÁ/è≤=:˝£`Ñ’¯à3Ã‹D‹ ÑbF˚ºLaTÓ•#`ø—‡‡ë£å§œÛE´;Ωü0π›3y<¶±uºàë®ÎÈ‚#
Å‚Ü≤%¶<˚:nz0±a¬¥V˛Ø:)mµÒÜ§˝@ò+¯ΩîœAS÷“-Ô≥}Z„ñA≈–}î≠ê˚,âêµÁõI§˝ﬂØ\ôÕP‘ødKı@y3Í/˜>‡MwäıÍ•—6À"Í®≠=eÊJ )U«ÚÒ,˚Ùøù•p≥1˚é2ëúg‚ıgƒèµï˚≠?I=K7◊é›)bñ'#a∂L>9˜‚wÏI8T!≠ï®8QIiG6,†UÉáâ¡◊∫≤gÀ`ç∂2~}î64o©¨• √9§8YÓM\Á.ı}Oó◊\4–CıîÔœù‰_úGá‹cáKπ|¥Ëe˛Œ≥úV∞ˆf(ô‹z4≠Áõ‰é7H˝‚ÿŸ,Á*˙=ÀK6%7°í˜π„'A‡M∞}]-I|ó‹ë™©:	ø	$órj‘<RAœJ∏œÉ™Öä≤Y/ëí∞öÙwç"‡tE∏ªµ]8dÅM6Iê…Îÿò∞"€£|qƒ•paR›A@˛ÁyÑ!+àyò> í:ñeﬂﬁôàÖµÙﬂ ¯ÉÁ≤∞I˛—Q gêÉ∂òßë∂ÃF‹º¶L4£ªÉ˝íùÒ~^∏ìãñZídl”—ß§ŒqÉï±√–∏0,=@(•õT;»˜!«†.˙÷5Â…ìYå˘ì¨;:*»i∂,â≠¡Ô£™µ¬à8yñvTqVΩ?AT)Ù˘TÀ≤«h8íŸo§Ë‡»‚S˝'Ô’ÒØ?L~‘~(Ÿ†(≥ˆF_ÍßT”c√ñ®0ﬂ7Ωïä'?=Èp˜Hƒ¯ä’0ü3iøµ•XÁ6Gãm‘`‚Ä,~gR‘ïc˛"ò†qåî>Pl‹&DA§ÎÓΩ±è~∑õ7»‹ôL'¯ü‹XKGãjA≈:f'ÄäÍï|/nªíx·˙M±Âfì7Y'"â(aÕ‰Q‚?ùîu¸Sg⁄∫«◊=O{<‘Î√ kMﬁ5:A±ˆPŒç≠™îT!≠€ÓdøWXÎ”ùy¶÷“ãî7üø€Q9∏˛í7âòêòD¿	Tœ4—œÍ^s¨OÏ⁄ˇœ/ h§Oä∏Êıc∏:ö{·+Ï∂°KQ~‘≥˚fî5› also need to handle implicit export elision for names declared as
   * types. In the second case, we must NOT do implicit named export elision,
   * but we must remove the runtime import if all exports are type exports.
   */
   processNamedExports() {
    if (!this.isTypeScriptTransformEnabled) {
      return false;
    }
    this.tokens.copyExpectedToken(tt._export);
    this.tokens.copyExpectedToken(tt.braceL);

    const isReExport = isExportFrom(this.tokens);
    let foundNonTypeExport = false;
    while (!this.tokens.matches1(tt.braceR)) {
      const specifierInfo = getImportExportSpecifierInfo(this.tokens);
      if (
        specifierInfo.isType ||
        (!isReExport && this.shouldElideExportedName(specifierInfo.leftName))
      ) {
        // Type export, so remove all tokens, including any comma.
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.removeToken();
        }
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.removeToken();
        }
      } else {
        // Non-type export, so copy all tokens, including any comma.
        foundNonTypeExport = true;
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.copyToken();
        }
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.copyToken();
        }
      }
    }
    this.tokens.copyExpectedToken(tt.braceR);

    if (!this.keepUnusedImports && isReExport && !foundNonTypeExport) {
      // This is a type-only re-export, so skip evaluating the other module. Technically this
      // leaves the statement as `export {}`, but that's ok since that's a no-op.
      this.tokens.removeToken();
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
    }

    return true;
  }

  /**
   * ESM elides all imports with the rule that we only elide if we see that it's
   * a type and never see it as a value. This is in contrast to CJS, which
   * elides imports that are completely unknown.
   */
   shouldElideExportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      this.declarationInfo.typeDeclarations.has(name) &&
      !this.declarationInfo.valueDeclarations.has(name)
    );
  }
}
